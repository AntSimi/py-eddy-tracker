#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Subset eddy Dataset
"""
from py_eddy_tracker import EddyParser
from py_eddy_tracker.observations.tracking import TrackEddiesObservations
import logging


def id_parser():
    parser = EddyParser('Eddy Identification')
    parser.add_argument('filename')
    parser.add_argument('filename_out')
    parser.add_argument('-p', '--period', nargs=2, type=int,
                        help='Start day and end day, if it s negative value we will add to day min and add to day max, if 0 it s not use')
    parser.add_argument('-l', '--length', nargs=2, type=int,
                        help='Minimal and maximal quantity of observation for one track, ones bounds could be negative, it will be not use')
    parser.add_argument('-f', '--full_path', action='store_true',
                        help='Extract path, if one obs or more are selected')
    parser.add_argument('-d', '--remove_incomplete', action='store_true',
                        help='Extract path only if all obs are selected')
    parser.add_argument('-a', '--area', nargs=4, type=float,
                        metavar=('llcrnrlon', 'llcrnrlat', 'urcrnrlon', 'urcrnrlat'),
                        help='Coordinates of bounding to extract'
                        )
    parser.add_argument('--remove_var', nargs='+', type=str, help='remove all listed variable')
    parser.add_argument('-i', '--ids', nargs='+', type=int, help='List of tracks which will be extract')
    parser.add_argument('-n', '--no_raw_mode', action='store_true',
                        help='Uncompress all data, could be create a memory error for huge file, but is safer for extern file of py eddy tracker')
    return parser


if __name__ == '__main__':
    args = id_parser().parse_args()

    # Original dataset
    dataset = TrackEddiesObservations.load_from_netcdf(
        args.filename,
        raw_data=False if args.no_raw_mode else True,
        remove_vars=args.remove_var)

    # Select with id
    if args.ids is not None:
        dataset = dataset.extract_ids(args.ids)

    # Select with length
    if args.length is not None:
        dataset = dataset.extract_with_length(args.length)

    # Select with a start date and end date
    if args.period is not None:
        dataset = dataset.extract_with_period(args.period, full_path=args.full_path,
                                              remove_incomplete=args.remove_incomplete)

    # Select track which go through an area
    if args.area is not None:
        area = dict(llcrnrlon=args.area[0],
                    llcrnrlat=args.area[1],
                    urcrnrlon=args.area[2],
                    urcrnrlat=args.area[3],
                    )
        dataset = dataset.extract_with_area(area, full_path=args.full_path,
                                            remove_incomplete=args.remove_incomplete)

    # if no data, no output will be written
    if len(dataset) == 0:
        logging.warning("No data are selected, out file couldn't be create")
    else:
        dataset.write_netcdf(filename=args.filename_out)
