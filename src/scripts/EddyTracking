#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
"""

from py_eddy_tracker import EddyParser
from glob import glob
from yaml import load as yaml_load
from py_eddy_tracker.tracking import Correspondances
from py_eddy_tracker.observations import \
    EddiesObservations, TrackEddiesObservations
import logging
from numpy import array, arange, bool_, uint16, unique, setdiff1d, \
    ones, zeros
import datetime as dt


def usage():
    """Usage
    """
    # Run using:
    parser = EddyParser(
        "Tool to use identification step to compute tracking")
    parser.add_argument('yaml_file',
                        help='Yaml file to configure py-eddy-tracker')
    yaml_file = parser.parse_args().yaml_file

    # Read yaml configuration file
    with open(yaml_file, 'r') as stream:
        config = yaml_load(stream)
    return config


if __name__ == '__main__':
    CONFIG = usage()

    NB_OBS_MIN = int(CONFIG['TRACK_DURATION_MIN'])
    NB_VIRTUAL_OBS_MAX_BY_SEGMENT = int(CONFIG['VIRTUAL_LEGNTH_MAX'])

    PATTERN = CONFIG['PATHS']['FILES_PATTERN']
    FILENAMES = glob(PATTERN)
    FILENAMES.sort()

    START_TIME = dt.datetime.now()
    logging.info('Start tracking on %d files', len(FILENAMES))


    CORRESPONDANCES = Correspondances(
        datasets=FILENAMES,
        virtual=NB_VIRTUAL_OBS_MAX_BY_SEGMENT)
        
    CORRESPONDANCES.track()
    logging.info('Track finish')
    logging.info('Start merging')
    
    CORRESPONDANCES.prepare_merging()
    
    CORRESPONDANCES.merge()

    # We flag obs
    if CORRESPONDANCES.virtual:
        FINAL_EDDIES['virtual'][:] = FINAL_EDDIES['time'] == 0

        FINAL_EDDIES.filled_by_interpolation(FINAL_EDDIES['virtual'] == 1)

    # Total running time
    FULL_TIME = dt.datetime.now() - START_TIME
    logging.info('Mean duration by loop : %s',
                 FULL_TIME / (len(FILENAMES) - 1))
    logging.info('Duration : %s', FULL_TIME)

    logging.info('The longest tracks have %d observations',
                 nb_obs_by_tracks.max())

    SUBSET_EDDIES = FINAL_EDDIES.extract_longer_eddies(
        NB_OBS_MIN, nb_obs_by_tracks.repeat(nb_obs_by_tracks))
    
    logging.info('%d tracks will be saved',
                 len(unique(SUBSET_EDDIES['track'])))

    SUBSET_EDDIES.write_netcdf()
